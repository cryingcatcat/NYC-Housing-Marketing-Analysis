# -*- coding: utf-8 -*-
"""LR Project Exploring Data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/110Re9tuuPbY2_pMG8t7Xy73HOq6cStA7
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# =========================
# 0. Load & quick overview
# =========================

# Put NY-House-Dataset.csv in the same folder as this script/notebook
df = pd.read_csv("NY-House-Dataset.csv")

print("Shape:", df.shape)
print("\nColumns:", df.columns.tolist())
print("\nPreview:")
print(df.head())

# ==========================================
# 1. Basic cleaning / helper filtered frames
# ==========================================

# Keep positive prices only
df = df[df["PRICE"] > 0].copy()

# Cap extreme outliers for exploration (this is only for EDA visuals)
price_cap = 5_000_000
df_price_trim = df[df["PRICE"] <= price_cap].copy()

# Clean square footage:
# - keep > 0
# - drop an extremely common suspicious mode if it dominates (e.g. 2184.21)
sqft = df["PROPERTYSQFT"]
valid_sqft_mask = sqft.notna() & (sqft > 0)

if not sqft.mode(dropna=True).empty:
    mode_sqft = float(sqft.mode(dropna=True)[0])
    # if one value occurs too often, treat it as placeholder and drop it
    if (sqft == mode_sqft).sum() > 0.15 * len(sqft):
        valid_sqft_mask &= (sqft != mode_sqft)

df_sqft = df[valid_sqft_mask].copy()

# Price per square foot
df_sqft["PRICE_PER_SQFT"] = df_sqft["PRICE"] / df_sqft["PROPERTYSQFT"]

# Top property types by count (for clearer plots)
top_types = df["TYPE"].value_counts().head(5).index.tolist()
df_top_types = df[df["TYPE"].isin(top_types)].copy()
df_sqft_top_types = df_sqft[df_sqft["TYPE"].isin(top_types)].copy()

# =========================
# 2. Graphs (9 insightful)
# =========================
# NOTE: All plots use matplotlib only.

# Graph 1: Distribution of listing prices (trimmed)
plt.figure(figsize=(10, 6))
plt.hist(df_price_trim["PRICE"], bins=40)
plt.xlabel("Listing Price (USD, <= $5M)")
plt.ylabel("Number of Listings")
plt.title("NYC Housing: Distribution of Listing Prices (Trimmed)")
plt.tight_layout()
plt.show()

# Graph 2: Log-scale distribution of prices
plt.figure(figsize=(10, 6))
log_prices = np.log10(df["PRICE"])
plt.hist(log_prices, bins=40)
plt.xlabel("log10(Price)")
plt.ylabel("Number of Listings")
plt.title("NYC Housing: Distribution of Prices (log10 scale)")
plt.tight_layout()
plt.show()

# Graph 3: Property type counts
plt.figure(figsize=(10, 6))
type_counts = df["TYPE"].value_counts().sort_values(ascending=False)
plt.bar(type_counts.index, type_counts.values)
plt.xticks(rotation=25, ha="right")
plt.ylabel("Number of Listings")
plt.title("Counts of Listings by Property Type")
plt.tight_layout()
plt.show()

# Graph 4: Boxplot of listing prices by top 5 property types (trimmed)
plt.figure(figsize=(10, 6))
data_box = [
    df_top_types[
        (df_top_types["TYPE"] == t) &
        (df_top_types["PRICE"] <= price_cap)
    ]["PRICE"]
    for t in top_types
]
plt.boxplot(data_box, labels=top_types, showfliers=False)
plt.ylabel("Listing Price (USD, <= $5M)")
plt.title("Listing Prices by Property Type (Top 5 Types)")
plt.xticks(rotation=20, ha="right")
plt.tight_layout()
plt.show()

# Graph 5: Boxplot of price per sqft by top 5 property types
plt.figure(figsize=(10, 6))
data_ppsqft = [
    df_sqft_top_types[df_sqft_top_types["TYPE"] == t]["PRICE_PER_SQFT"].dropna()
    for t in top_types
]
plt.boxplot(data_ppsqft, labels=top_types, showfliers=False)
plt.ylabel("Price per Sqft (USD)")
plt.title("Price per Sqft by Property Type (Top 5 Types)")
plt.xticks(rotation=20, ha="right")
plt.tight_layout()
plt.show()

# Graph 6: Scatter plot - size vs price (trimmed)
plt.figure(figsize=(10, 6))
df_scatter = df_sqft[df_sqft["PRICE"] <= price_cap]
plt.scatter(df_scatter["PROPERTYSQFT"], df_scatter["PRICE"], alpha=0.4)
plt.xlabel("Property Size (Sqft)")
plt.ylabel("Listing Price (USD, <= $5M)")
plt.title("Relationship Between Size and Price")
plt.tight_layout()
plt.show()

# Graph 7: Scatter plot - beds vs price (trimmed)
plt.figure(figsize=(8, 6))
df_beds = df_price_trim[df_price_trim["BEDS"].notna()]
plt.scatter(df_beds["BEDS"], df_beds["PRICE"], alpha=0.4)
plt.xlabel("Number of Bedrooms")
plt.ylabel("Listing Price (USD, <= $5M)")
plt.title("Bedrooms vs Price")
plt.xticks(sorted(df_beds["BEDS"].unique()))
plt.tight_layout()
plt.show()

# Graph 8: Geographic scatter - latitude vs longitude, point size ~ price
plt.figure(figsize=(10, 8))
geo = df_price_trim.dropna(subset=["LATITUDE", "LONGITUDE"])
sizes = (geo["PRICE"] / geo["PRICE"].max()) * 50  # scaled for visibility
plt.scatter(geo["LONGITUDE"], geo["LATITUDE"], s=sizes, alpha=0.3)
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("Spatial Distribution of Listings (Point Size âˆ Price, <= $5M)")
plt.tight_layout()
plt.show()

# Graph 9: Correlation heatmap of numeric variables
plt.figure(figsize=(8, 6))
num_cols = ["PRICE", "BEDS", "BATH", "PROPERTYSQFT"]
corr = df_sqft[num_cols].corr()
im = plt.imshow(corr, interpolation="nearest")
plt.colorbar(im, fraction=0.046, pad=0.04)
plt.xticks(range(len(num_cols)), num_cols, rotation=20, ha="right")
plt.yticks(range(len(num_cols)), num_cols)
plt.title("Correlation Heatmap: Price, Beds, Bath, Sqft")

# annotate cells with correlation values
for i in range(len(num_cols)):
    for j in range(len(num_cols)):
        plt.text(j, i, f"{corr.iloc[i, j]:.2f}",
                 ha="center", va="center")

plt.tight_layout()
plt.show()